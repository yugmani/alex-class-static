<div id="app">
  <h1>Class Static Initialization Blocks in JavaScript</h1>
  <ul>
    <li>
      <h3>Classes, fields and field initialization in a brief</h3>
      <ol>
        <li>It is a part of the ECMAScript 2022 proposal.</li>
        <li>
          While creating a JavaScript class, we can add public, static and
          private fields and methods.
        </li>
        <li>
          Depending on current situation and our intent, we choose a type of a
          property or method.
        </li>
        <li>
          Public fields and methods are better for some situation while private
          are better for another. You can initialize these fields or not.
        </li>
        <li>
          We can also define and initialize class properties inside the
          constructor method. This is useful when we have to create class
          properties based on class parameters. The constructor method also
          allows us to initialize public as well as private fields.
        </li>
      </ol>
    </li>

    <li>
      <h3>The Problem with Static Fields(hint:initialization)</h3>
      <ol>
        <li>
          The constructor method does not allow to initialize static fields.This
          may not be a real problem if all static fields you need can be
          initialized when you define them. The usual way is to create new
          static field and assign it some value.
        </li>
        <li>
          What if we want to initialize the static field more dynamically? For
          example: for Library class, it requires manual update of both fields;
          books and booksToReadCount to keep them in sync.
        </li>
        <li>
          We may define a static field without initializing it, or initialize it
          with some placeholder value. Then add constructor and use it to update
          the value of that static field. But this
          <strong>doesn't work</strong>. That field remains
          <em>undefined</em> or keep the placeholder value.
        </li>
      </ol>
    </li>
    <li>
      <h3>Solution with External Resources</h3>
      <ol>
        <li>One way to solve this problem is to use external resources.</li>
        <li>
          We create a new function outside the class and assign call to that
          function to the static field.
        </li>
        <li>
          The value returned by the function will become the value of the static
          field.
        </li>
        <li>
          This solution does the job. The downside is that it requires that
          external function. If we use approach multiple times out code can
          quickly become less clear.
        </li>
      </ol>
    </li>
    <li>
      <h3>Solution with Static Initialization Blocks</h3>
      <ol>
        <li>
          <strong>Static initialization blocks</strong> is an alternative
          solution offered by ES2022.
        </li>
        <li>
          These static initialization blocks allow us to create code blocks
          inside the class. We can use these blocks to execute any operation we
          need.
        </li>
        <li>
          We define the class and define the first static field for example
          'books' and assign it with the array of 'books'. Next, we define the
          second field such as 'booksToReadCount', but we don't initialize it.
        </li>
        <li>
          Now we add the static initialization block and in this block we
          execute any necessary operation and initialize the booksToReadCount.
        </li>
      </ol>
    </li>
    <li>
      <h3>Syntax and rules for static initialization blocks</h3>
      <ol>
        <li>
          The syntax is very simple. There is a 'static' keyword and code block
          defined with curly braces({}). Inside the code block, we put the code
          that we want to execute including the initialization of static fields.
        </li>
        <li>
          Every code block creates new block scope. So, it is useful to create
          temporary variables we may need. Note that this applies only to
          block-scoped variables 'const' and 'let' but not to 'var'.
        </li>
        <li>
          We can have as many static initialization blocks in a class as we
          need.
        </li>
        <li>
          Static blocks are executed during the execution of initializers of
          static fields.
        </li>
        <li>
          If we extend classes, static fields of a superclass will be executed
          before the static fields of its subclasses.
        </li>
      </ol>
    </li>
  </ul>
  <p>
    <a href="https://blog.alexdevero.com/class-static-initialization-blocks/"
      >class-static-initialization-blocks by Alex Devero</a
    >
  </p>
</div>
